<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TidakMungkin — Architecture</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #07070a;
      color: #eaeaf0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      overflow: hidden;
    }
    .hud {
      position: fixed;
      left: 14px;
      top: 12px;
      z-index: 10;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .btn{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color:#eaeaf0;
      padding:10px 12px;
      border-radius:12px;
      font-weight:800;
      font-size:12px;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn:hover{ background: rgba(255,255,255,.07); border-color: rgba(255,255,255,.22); }
    .pill{ display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.04); font-size:11px; color:#b9b9c6; }
    .legend {
      position: fixed;
      right: 14px;
      top: 12px;
      z-index: 10;
      max-width: min(440px, calc(100vw - 28px));
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      padding: 12px;
      backdrop-filter: blur(10px);
    }
    .k{ color:#b9b9c6; font-size: 12px; text-transform: uppercase; letter-spacing: .08em; }
    .v{ font-weight: 800; margin-top: 6px; line-height: 1.45; }
    #canvas { position: fixed; inset: 0; }
    .hint { color:#b9b9c6; font-size: 12px; margin-top: 8px; line-height: 1.4; }
    @media (max-width: 520px){
      .legend{ left: 14px; right: 14px; top: auto; bottom: 14px; }
    }
  </style>
</head>
<body>
  <!-- Import Map for Three.js module resolution -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <div class="hud">
    <span style="font-weight:800;font-size:14px;color:#00ffc6;margin-right:8px;">TidakMungkin</span>
    <a class="btn" href="./">← Home</a>
    <a class="btn" href="./proof.html">Proof</a>
    <span class="pill">drag rotate · scroll zoom · right-drag pan</span>
  </div>

  <div class="legend">
    <div class="k">Architecture (public view)</div>
    <div class="v">OpenClaw → Cron → Scripts → status.json/proof.html → Alerts</div>
    <div class="hint">
      This is a high-level map (no secrets). Nodes are grouped by: runtime, data sources, RAG/memory, and delivery channels.
    </div>
  </div>

  <div id="canvas"></div>
  <div id="fallback" class="legend" style="display:none; left:14px; right:14px; top:72px; max-width: none;">
    <div class="k">3D view unavailable</div>
    <div class="v" style="font-weight:700;">Your browser (often in-app browsers) may block WebGL or cross-site modules.</div>
    <div class="hint">
      Try opening in Safari/Chrome, or use the static architecture below.
      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
        <a class="btn" href="./arch-static.html">Open static arch</a>
        <a class="btn" href="https://tidakmungkinai.github.io/arch.html" target="_blank" rel="noopener noreferrer">Open in browser</a>
      </div>
    </div>
  </div>

  <script type="module">
    // If WebGL is blocked (common in Telegram in-app browser), show fallback.
    const fallback = document.getElementById('fallback');
    const showFallback = () => { if (fallback) fallback.style.display = 'block'; };
    if (!window.WebGLRenderingContext) {
      showFallback();
      throw new Error('WebGL not supported');
    }

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const el = document.getElementById('canvas');

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x030308, 0.022);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 200);
    camera.position.set(0, 12, 32);

    let renderer;
    try {
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    } catch (e) {
      showFallback();
      throw e;
    }
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    el.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 2, 0);
    controls.maxDistance = 60;
    controls.minDistance = 8;

    // Minimal lighting
    scene.add(new THREE.AmbientLight(0x111122, 0.4));
    const keyLight = new THREE.PointLight(0x00ffc6, 1.5, 50);
    keyLight.position.set(0, 15, 0);
    scene.add(keyLight);

    // Cyberpunk colors
    const CYAN = 0x00ffc6;
    const PURPLE = 0x8c52ff;
    const MUTED = 0x4a4a5a;

    function makeLabel(text, accent = false) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = '600 16px ui-monospace, Menlo, Monaco, monospace';
      const w = Math.ceil(ctx.measureText(text).width) + 24;
      const h = 32;
      canvas.width = w;
      canvas.height = h;
      // Minimal bg
      ctx.fillStyle = accent ? 'rgba(0,255,198,0.08)' : 'rgba(10,10,15,0.85)';
      ctx.fillRect(0, 0, w, h);
      // Border line
      ctx.strokeStyle = accent ? 'rgba(0,255,198,0.5)' : 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, w-1, h-1);
      // Text
      ctx.fillStyle = accent ? '#00ffc6' : '#888899';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, 12, h/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.9 });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(w/40, h/40, 1);
      return spr;
    }

    // Wireframe node with glow
    function node({ name, color = CYAN, pos = [0,0,0], size = 1, primary = false }) {
      const group = new THREE.Group();
      group.position.set(...pos);

      // Core icosahedron wireframe
      const geo = new THREE.IcosahedronGeometry(size, primary ? 1 : 0);
      const edges = new THREE.EdgesGeometry(geo);
      const lineMat = new THREE.LineBasicMaterial({ 
        color, 
        transparent: true, 
        opacity: primary ? 0.9 : 0.7 
      });
      const wireframe = new THREE.LineSegments(edges, lineMat);
      group.add(wireframe);

      // Inner glow core
      const coreMat = new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: primary ? 0.15 : 0.08,
      });
      const core = new THREE.Mesh(new THREE.IcosahedronGeometry(size * 0.6, 0), coreMat);
      group.add(core);

      // Holographic ring for primary nodes
      if (primary) {
        const ringGeo = new THREE.TorusGeometry(size * 1.5, 0.02, 8, 32);
        const ringMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2;
        group.add(ring);
        group.userData.ring = ring;
      }

      scene.add(group);

      // Label
      const label = makeLabel(name, primary);
      label.position.set(pos[0], pos[1] + size + 0.8, pos[2]);
      scene.add(label);

      return { group, wireframe, pos, size, color, label };
    }

    // Animated connection with particles
    function link(a, b, color = CYAN) {
      const pts = [new THREE.Vector3(...a.pos), new THREE.Vector3(...b.pos)];
      
      // Base line
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.2 });
      const line = new THREE.Line(geom, mat);
      scene.add(line);

      // Data stream particles
      const particleCount = 3;
      const particles = [];
      for (let i = 0; i < particleCount; i++) {
        const pGeo = new THREE.SphereGeometry(0.06, 4, 4);
        const pMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 });
        const p = new THREE.Mesh(pGeo, pMat);
        p.userData.offset = i / particleCount;
        p.userData.start = pts[0];
        p.userData.end = pts[1];
        scene.add(p);
        particles.push(p);
      }

      return { line, particles };
    }

    // --- Graph Layout (cleaner, grouped) ---
    const nGateway = node({ name: 'GATEWAY', color: CYAN, pos: [0, 5, 0], size: 1.4, primary: true });

    // Left cluster: Automation
    const nCron = node({ name: 'CRON', color: PURPLE, pos: [-7, 3, 0], size: 0.9 });
    const nRunner = node({ name: 'RUNNER', color: MUTED, pos: [-11, 1, 0], size: 0.7 });
    const nCermat = node({ name: 'CERMAT', color: CYAN, pos: [-14, -1, -2], size: 0.65 });
    const nHandal = node({ name: 'HANDAL', color: CYAN, pos: [-14, -1, 2], size: 0.65 });

    // Right cluster: Memory/RAG
    const nQmd = node({ name: 'QMD', color: CYAN, pos: [8, 3, -3], size: 0.8 });
    const nTitan = node({ name: 'TITAN', color: PURPLE, pos: [8, 3, 3], size: 0.8 });

    // Bottom: Output
    const nStatus = node({ name: 'STATUS', color: MUTED, pos: [3, 0, 0], size: 0.7 });
    const nGhPages = node({ name: 'DEPLOY', color: CYAN, pos: [10, -1, 0], size: 0.75 });

    // Delivery channels
    const nTelegram = node({ name: 'TG', color: CYAN, pos: [-3, -3, -8], size: 0.6 });
    const nWhatsApp = node({ name: 'WA', color: CYAN, pos: [-3, -3, 8], size: 0.6 });

    // Links (data flows)
    const links = [
      link(nGateway, nCron, PURPLE),
      link(nCron, nRunner, MUTED),
      link(nRunner, nCermat, CYAN),
      link(nRunner, nHandal, CYAN),
      link(nGateway, nQmd, CYAN),
      link(nGateway, nTitan, PURPLE),
      link(nGateway, nStatus, MUTED),
      link(nStatus, nGhPages, CYAN),
      link(nGateway, nTelegram, CYAN),
      link(nGateway, nWhatsApp, CYAN),
    ];

    // Minimal grid floor
    const gridGeo = new THREE.PlaneGeometry(80, 80, 40, 40);
    const gridMat = new THREE.MeshBasicMaterial({ 
      color: 0x0a0a12, 
      wireframe: true, 
      transparent: true, 
      opacity: 0.15 
    });
    const grid = new THREE.Mesh(gridGeo, gridMat);
    grid.rotation.x = -Math.PI / 2;
    grid.position.y = -6;
    scene.add(grid);

    // Optional: floating particles atmosphere
    const dustGeo = new THREE.BufferGeometry();
    const dustCount = 200;
    const dustPos = new Float32Array(dustCount * 3);
    for (let i = 0; i < dustCount; i++) {
      dustPos[i*3] = (Math.random() - 0.5) * 60;
      dustPos[i*3+1] = (Math.random() - 0.5) * 30;
      dustPos[i*3+2] = (Math.random() - 0.5) * 60;
    }
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    const dustMat = new THREE.PointsMaterial({ color: CYAN, size: 0.08, transparent: true, opacity: 0.3 });
    const dust = new THREE.Points(dustGeo, dustMat);
    scene.add(dust);

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    let t = 0;
    function animate(){
      t += 0.008;

      // Pulse gateway
      const pulse = 1 + Math.sin(t * 2) * 0.05;
      nGateway.group.scale.set(pulse, pulse, pulse);
      nGateway.group.position.y = 5 + Math.sin(t) * 0.15;

      // Rotate rings
      if (nGateway.group.userData.ring) {
        nGateway.group.userData.ring.rotation.z += 0.005;
      }

      // Animate data stream particles
      links.forEach(l => {
        l.particles.forEach(p => {
          const prog = (t * 0.3 + p.userData.offset) % 1;
          p.position.lerpVectors(p.userData.start, p.userData.end, prog);
        });
      });

      // Slow dust rotation
      dust.rotation.y += 0.0003;

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
